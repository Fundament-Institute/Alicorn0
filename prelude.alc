
# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let omega = 9
# FIXME: apparently variables aren't allowed here
#let universe = type_(omega, 1)
let universe = type_(9, 1)
let type-omega = type_(9, 0)
let type-omega+1 = type_(10, 0)

# nor expressions
####let implicit-wrap = lambda_curry ((T : type_(omega + 1, 0)))
	lambda (x : T)
		wrap T x

let implicit-wrap = lambda_curry ((T : type-omega+1))
	lambda (x : T)
		wrap T x

let implicit-unwrap = lambda_implicit (T : type-omega+1)
	lambda (x : wrapped(T))
		unwrap T x

####let implicit-unstrict-wrap = lambda_curry ((T : type-omega+1))
		lambda (x : T)
			unstrict-wrap T x

	let implicit-unstrict-unwrap = lambda_implicit (T : type-omega+1)
		lambda (x : unstrict-wrapped(T))
			unstrict-unwrap T x

let tuple-of-implicit = lambda_implicit (T : type-omega+1)
	lambda_single (xs : T)
		xs

let explicit-unwrap = unwrap
let wrap = implicit-wrap
let unwrap = implicit-unwrap
####let unstrict-wrap = implicit-unstrict-wrap
	let unstrict-unwrap = implicit-unstrict-unwrap

let host-bool-wrap            = intrinsic "return terms.strict_value.host_bool_type"      : wrapped(host-type)
let host-string-wrap          = intrinsic "return terms.strict_value.host_string_type"    : wrapped(host-type)
let host-syntax-wrap          = intrinsic "return terms.host_syntax_type"          : wrapped(host-type)
let host-environment-wrap     = intrinsic "return terms.host_environment_type"     : wrapped(host-type)
let host-goal-wrap            = intrinsic "return terms.host_goal_type"            : wrapped(host-type)
let host-inferrable-term-wrap = intrinsic "return terms.host_inferrable_term_type" : wrapped(host-type)
let host-checkable-term-wrap  = intrinsic "return terms.host_checkable_term_type"  : wrapped(host-type)
let host-lua-error-wrap       = intrinsic "return terms.host_lua_error_type"       : wrapped(host-type)

let host-bool            = unwrap(host-bool-wrap)
let host-string          = unwrap(host-string-wrap)
let host-syntax          = unwrap(host-syntax-wrap)
let host-environment     = unwrap(host-environment-wrap)
let host-goal            = unwrap(host-goal-wrap)
let host-inferrable-term = unwrap(host-inferrable-term-wrap)
let host-checkable-term  = unwrap(host-checkable-term-wrap)
let host-lua-error       = unwrap(host-lua-error-wrap)

let srel = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#srel", function(target)
					return U.notail(terms.typed_term.srel_type(target))
				end))
			:
			wrapped (forall ((target : U)) -> (rel : U))

let variance = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#variance", function(target)
					return U.notail(terms.typed_term.variance_type(target))
				end))
			:
			wrapped (forall ((target : U)) -> (res : U))

let subtyping = intrinsic "return evaluator.UniverseOmegaRelation" : srel(type-omega)

let tuple-desc-type = lambda_implicit (U : universe)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-type", function(a_universe)
					return U.notail(terms.typed_term.tuple_desc_type(a_universe))
				end))
			:
			wrapped (forall ((a-universe : U)) -> (desc : U))

let tuple-desc-relation = intrinsic "return evaluator.TupleDescRelation" : srel(tuple-desc-type(type-omega))

let _|_ = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#union", function(left, right)
					return U.notail(terms.typed_term.union_type(left, right))
				end))
			:
			wrapped (forall (left : U, right : U) -> (union : U))

let _&_ = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#intersection", function(left, right)
					return U.notail(terms.typed_term.intersection_type(left, right))
				end))
			:
			wrapped (forall (left : U, right : U) -> (intersection : U))

let covariant = lambda_curry (U : universe, a : U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#covariant", function(rel)
					local positive = terms.typed_term.literal(terms.strict_value.host_value(true))
					return U.notail(terms.typed_term.variance_cons(positive, rel))
				end))
			:
			wrapped (forall ((rel : srel(a))) -> (covariant-rel : variance(a)))

let contravariant = lambda_curry (U : universe, a : U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#contravariant", function(rel)
					local positive = terms.typed_term.literal(terms.strict_value.host_value(false))
					return U.notail(terms.typed_term.variance_cons(positive, rel))
				end, "rel"))
			:
			wrapped (forall ((rel : srel(a))) -> (contravariant-rel : variance(a)))


let tuple-type = lambda_implicit (U : universe)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-type", function(desc)
					return U.notail(terms.typed_term.tuple_type(desc))
				end, "desc"))
			:
			wrapped (forall ((desc : tuple-desc-type(U))) -> (T : U))

let host-tuple-type =
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#host-tuple-type", function(desc)
					return U.notail(terms.typed_term.host_tuple_type(desc))
				end, "desc"))
			:
			wrapped (forall ((desc : tuple-desc-type(host-type))) -> (T : host-type))

let host-family-sig-variances = lambda (signature : type_(1, 0))
	let inner = intrinsic
		""""
			return base_env.convert_sig
		:
		host-func-type ((signature : wrapped(type_(1, 0)))) -> ((srel_type : wrapped(type_(1, 0))))
	let (srels-t) = inner(wrap(signature))
	unwrap(srels-t)

let host-string-concat = intrinsic "return function(a, b) return U.notail(a .. b) end" :
	host-func-type (a : host-string, b : host-string) -> ((c : host-string))

# TODO: now that we have effectful programs, work to switch this into using an effect to serialize the operations
# lmao bootstrapping problem
let host-unique-id-wrap = intrinsic
	""""
		local id = { name = "unique_id" }
		evaluator.register_host_srel(id, evaluator.IndepTupleRelation())
		return U.notail(terms.strict_value.host_user_defined_type(id, terms_gen.declare_array(terms.strict_value)()))
	:
	wrapped(host-type)
let host-unique-id = unwrap(host-unique-id-wrap)
let new-host-unique-id = lambda (name : host-string)
	let source0 = "return { name = \""
	let (source1) = host-string-concat(source0, name)
	let (source2) = host-string-concat(source1, "\" }")
	intrinsic source2 : host-unique-id

let new-host-type-family = lambda (unique-id : host-unique-id, signature : type_(1, 0), variance : host-family-sig-variances(signature))
	let inner = intrinsic
		""""
			return base_env.new_host_type_family
		:
		host-func-type (
				unique-id  : host-unique-id,
				signature_ : wrapped(type_(1, 0)),
				variance_  : wrapped(host-family-sig-variances(unwrap(signature_))))
			->
			((family : wrapped(unwrap(signature_))))
	let (family) = inner(unique-id, wrap(signature), wrap(variance))
	unwrap(family)
let new-host-type = lambda (unique-id : host-unique-id)
	let Tfam = new-host-type-family unique-id
		forall () -> (T : host-type)
		tuple-of-implicit()
	Tfam()

##### SNIP STARTING FROM host-array-type #####





##### GLSL PRELUDE START HERE #####

let glsl-float = host-number
let glsl-vec2 = new-host-type(new-host-unique-id("glsl-vec2"))
let glsl-vec3 = new-host-type(new-host-unique-id("glsl-vec3"))
let glsl-vec4 = new-host-type(new-host-unique-id("glsl-vec4"))
let glsl-mat4 = new-host-type(new-host-unique-id("glsl-mat4"))

let host-add-float = intrinsic
	""""
		local host_add_float = function(l, r) return l + r end
		glsl_registry[host_add_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" + ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_add_float
	:
	host-func-type (left : glsl-float, right : glsl-float) -> ((sum : glsl-float))
let _+_ = lambda (left : glsl-float, right : glsl-float)
	let (sum) = host-add-float(left, right)
	sum

let host-sub-float = intrinsic
	""""
		local host_sub_float = function(l, r) return l - r end
		glsl_registry[host_sub_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" - ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_sub_float
	:
	host-func-type (left : glsl-float, right : glsl-float) -> ((difference : glsl-float))
let _-_ = lambda (left : glsl-float, right : glsl-float)
	let (difference) = host-sub-float(left, right)
	difference

let host-mul-float = intrinsic
	""""
		local host_mul_float = function(l, r) return l * r end
		glsl_registry[host_mul_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" * ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_mul_float
	:
	host-func-type (left : glsl-float, right : glsl-float) -> ((product : glsl-float))
let _*_ = lambda (left : glsl-float, right : glsl-float)
	let (product) = host-mul-float(left, right)
	product

let host-mk-vec2 = intrinsic
	""""
		local vec2_mt = {}
		local host_mk_vec2 = function(x, y) return setmetatable({ x = x, y = y }, vec2_mt) end
		glsl_registry[host_mk_vec2] = function(pp, varnames, x, y)
			pp:unit("vec2(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(y, varnames)
			pp:unit(")")
		end
		glsl_registry[vec2_mt] = function(pp, vec, varnames)
			return glsl_registry[host_mk_vec2](pp, varnames, vec.x, vec.y)
		end
		return host_mk_vec2
	:
	host-func-type (x : glsl-float, y : glsl-float) -> ((vec : glsl-vec2))
let mk-vec2 = lambda (x : glsl-float, y : glsl-float)
	let (vec) = host-mk-vec2(x, y)
	vec

let host-mk-vec3 = intrinsic
	""""
		local vec3_mt = {}
		local host_mk_vec3 = function(x, y) return setmetatable({ x = x, y = y, z = z }, vec3_mt) end
		glsl_registry[host_mk_vec3] = function(pp, varnames, x, y, z)
			pp:unit("vec3(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(y, varnames)
			pp:unit(", ")
			pp:any(z, varnames)
			pp:unit(")")
		end
		glsl_registry[vec3_mt] = function(pp, vec, varnames)
			return glsl_registry[host_mk_vec3](pp, varnames, vec.x, vec.y, vec.z)
		end
		return host_mk_vec3
	:
	host-func-type (x : glsl-float, y : glsl-float, z : glsl-float) -> ((vec : glsl-vec3))
let mk-vec3 = lambda (x : glsl-float, y : glsl-float, z : glsl-float)
	let (vec) = host-mk-vec3(x, y, z)
	vec

let host-mk-vec4 = intrinsic
	""""
		local vec4_mt = {}
		local host_mk_vec4 = function(x, y, z, w) return setmetatable({ x = x, y = y, z = z, w = w }, vec4_mt) end
		glsl_registry[host_mk_vec4] = function(pp, varnames, x, y, z, w)
			pp:unit("vec4(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(y, varnames)
			pp:unit(", ")
			pp:any(z, varnames)
			pp:unit(", ")
			pp:any(w, varnames)
			pp:unit(")")
		end
		glsl_registry[vec4_mt] = function(pp, vec, varnames)
			return glsl_registry[host_mk_vec4](pp, varnames, vec.x, vec.y, vec.z, vec.w)
		end
		return host_mk_vec4
	:
	host-func-type (x : glsl-float, y : glsl-float, z : glsl-float, w : glsl-float) -> ((vec : glsl-vec4))
let mk-vec4 = lambda (x : glsl-float, y : glsl-float, z : glsl-float, w : glsl-float)
	let (vec) = host-mk-vec4(x, y, z, w)
	vec

let host-mk-mat4 = intrinsic
	""""
		local mat4_mt = {}
		local host_mk_mat4 = function(a, b, c, d)
			return setmetatable({
				ax = a.x, bx = b.x, cx = c.x, dx = d.x,
				ay = a.y, by = b.y, cy = c.y, dy = d.y,
				az = a.z, bz = b.z, cz = c.z, dz = d.z,
				aw = a.w, bw = b.w, cw = c.w, dw = d.w,
			}, mat4_mt)
		end
		glsl_registry[host_mk_mat4] = function(pp, varnames, a, b, c, d)
			pp:unit("mat4(")
			pp:any(a, varnames)
			pp:unit(", ")
			pp:any(b, varnames)
			pp:unit(", ")
			pp:any(c, varnames)
			pp:unit(", ")
			pp:any(d, varnames)
			pp:unit(")")
		end
		glsl_registry[mat4_mt] = function(pp, mat, varnames)
			pp:unit("/* NYI: repr a mat4! */")
		end
		return host_mk_mat4
	:
	host-func-type (a : glsl-vec4, b : glsl-vec4, c : glsl-vec4, d : glsl-vec4) -> ((mat : glsl-mat4))
let mk-mat4 = lambda (a : glsl-vec4, b : glsl-vec4, c : glsl-vec4, d : glsl-vec4)
	let (mat) = host-mk-mat4(a, b, c, d)
	mat

let host-get-vec2-x = intrinsic
	""""
		local host_get_vec2_x = function(vec) return vec.x end
		glsl_registry[host_get_vec2_x] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".x")
		end
		return host_get_vec2_x
	:
	host-func-type ((vec : glsl-vec2)) -> ((x : glsl-float))
let host-get-vec2-y = intrinsic
	""""
		local host_get_vec2_y = function(vec) return vec.y end
		glsl_registry[host_get_vec2_y] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".y")
		end
		return host_get_vec2_y
	:
	host-func-type ((vec : glsl-vec2)) -> ((y : glsl-float))
let split-vec2 = lambda (vec : glsl-vec2)
	let (x) = host-get-vec2-x(vec)
	let (y) = host-get-vec2-y(vec)
	tuple-of-implicit(x, y)


let host-get-vec3-x = intrinsic
	""""
		local host_get_vec3_x = function(vec) return vec.x end
		glsl_registry[host_get_vec3_x] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".x")
		end
		return host_get_vec3_x
	:
	host-func-type ((vec : glsl-vec3)) -> ((x : glsl-float))
let host-get-vec3-y = intrinsic
	""""
		local host_get_vec3_y = function(vec) return vec.y end
		glsl_registry[host_get_vec3_y] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".y")
		end
		return host_get_vec3_y
	:
	host-func-type ((vec : glsl-vec3)) -> ((y : glsl-float))
let host-get-vec3-z = intrinsic
	""""
		local host_get_vec3_z = function(vec) return vec.z end
		glsl_registry[host_get_vec3_z] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".z")
		end
		return host_get_vec3_z
	:
	host-func-type ((vec : glsl-vec3)) -> ((z : glsl-float))
let split-vec3 = lambda (vec : glsl-vec3)
	let (x) = host-get-vec3-x(vec)
	let (y) = host-get-vec3-y(vec)
	let (z) = host-get-vec3-z(vec)
	tuple-of-implicit(x, y, z)

let host-get-vec4-x = intrinsic
	""""
		local host_get_vec4_x = function(vec) return vec.x end
		glsl_registry[host_get_vec4_x] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".x")
		end
		return host_get_vec4_x
	:
	host-func-type ((vec : glsl-vec4)) -> ((x : glsl-float))
let host-get-vec4-y = intrinsic
	""""
		local host_get_vec4_y = function(vec) return vec.y end
		glsl_registry[host_get_vec4_y] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".y")
		end
		return host_get_vec4_y
	:
	host-func-type ((vec : glsl-vec4)) -> ((y : glsl-float))
let host-get-vec4-z = intrinsic
	""""
		local host_get_vec4_z = function(vec) return vec.z end
		glsl_registry[host_get_vec4_z] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".z")
		end
		return host_get_vec4_z
	:
	host-func-type ((vec : glsl-vec4)) -> ((z : glsl-float))
let host-get-vec4-w = intrinsic
	""""
		local host_get_vec4_w = function(vec) return vec.w end
		glsl_registry[host_get_vec4_w] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".w")
		end
		return host_get_vec4_w
	:
	host-func-type ((vec : glsl-vec4)) -> ((w : glsl-float))
let split-vec4 = lambda (vec : glsl-vec4)
	let (x) = host-get-vec4-x(vec)
	let (y) = host-get-vec4-y(vec)
	let (z) = host-get-vec4-z(vec)
	let (w) = host-get-vec4-w(vec)
	tuple-of-implicit(x, y, z, w)

let host-mul-mat4-vec4 = intrinsic
	""""
		local host_mul_mat4_vec4 = function(left, right)
			return setmetatable({
				x = left.ax * right.x + left.bx * right.y + left.cx * right.z + left.dx * right.w,
				y = left.ay * right.x + left.by * right.y + left.cy * right.z + left.dy * right.w,
				z = left.az * right.x + left.bz * right.y + left.cz * right.z + left.dz * right.w,
				w = left.aw * right.x + left.bw * right.y + left.cw * right.z + left.dw * right.w,
			}, glsl_registry["vec4"])
		end
		glsl_registry[host_mul_mat4_vec4] = function(pp, varnames, left, right)
			pp:unit("(")
			pp:any(left, varnames)
			pp:unit(" * ")
			pp:any(right, varnames)
			pp:unit(")")
		end
		return host_mul_mat4_vec4
	:
	host-func-type (left : glsl-mat4, right : glsl-vec4) -> ((product : glsl-vec4))
let mul-mat4-vec4 = lambda (left : glsl-mat4, right : glsl-vec4)
	let (product) = host-mul-mat4-vec4(left, right)
	product

let host-mul-mat4-mat4 = intrinsic
	""""
		local host_mul_mat4_mat4 = function(left, right)
			return setmetatable({
				ax = left.ax * right.ax + left.bx * right.ay + left.cx * right.az + left.dx * right.aw,
				ay = left.ay * right.ax + left.by * right.ay + left.cy * right.az + left.dy * right.aw,
				az = left.az * right.ax + left.bz * right.ay + left.cz * right.az + left.dz * right.aw,
				aw = left.aw * right.ax + left.bw * right.ay + left.cw * right.az + left.dw * right.aw,

				bx = left.ax * right.bx + left.bx * right.by + left.cx * right.bz + left.dx * right.bw,
				by = left.ay * right.bx + left.by * right.by + left.cy * right.bz + left.dy * right.bw,
				bz = left.az * right.bx + left.bz * right.by + left.cz * right.bz + left.dz * right.bw,
				bw = left.aw * right.bx + left.bw * right.by + left.cw * right.bz + left.dw * right.bw,

				cx = left.ax * right.cx + left.bx * right.cy + left.cx * right.cz + left.dx * right.cw,
				cy = left.ay * right.cx + left.by * right.cy + left.cy * right.cz + left.dy * right.cw,
				cz = left.az * right.cx + left.bz * right.cy + left.cz * right.cz + left.dz * right.cw,
				cw = left.aw * right.cx + left.bw * right.cy + left.cw * right.cz + left.dw * right.cw,

				dx = left.ax * right.dx + left.bx * right.dy + left.cx * right.dz + left.dx * right.dw,
				dy = left.ay * right.dx + left.by * right.dy + left.cy * right.dz + left.dy * right.dw,
				dz = left.az * right.dx + left.bz * right.dy + left.cz * right.dz + left.dz * right.dw,
				dw = left.aw * right.dx + left.bw * right.dy + left.cw * right.dz + left.dw * right.dw,
			}, glsl_registry["mat4"])
		end
		glsl_registry[host_mul_mat4_mat4] = function(pp, varnames, left, right)
			pp:unit("(")
			pp:any(left, varnames)
			pp:unit(" * ")
			pp:any(right, varnames)
			pp:unit(")")
		end
		return host_mul_mat4_mat4
	:
	host-func-type (left : glsl-mat4, right : glsl-mat4) -> ((product : glsl-mat4))
let mul-mat4-mat4 = lambda (left : glsl-mat4, right : glsl-mat4)
	let (product) = host-mul-mat4-mat4(left, right)
	product

let host-tuple-of = lambda (desc : tuple-desc-type(host-type))
	intrinsic "return function(...) return ... end" :
		host-func-type (t : host-tuple-type(desc)) -> (t : host-tuple-type(desc))

let tuple-desc-empty = lambda (U : universe)
	let empty = intrinsic "return terms.empty:unwrap_strict()" : wrapped(tuple-desc-type(U))
	unwrap(empty)
let tuple-desc-elem-explicit = lambda (U : universe)
	let U-tuple-desc-type = tuple-desc-type(U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-elem-explicit", function(desc, elem)
					return U.notail(terms.typed_cons(desc, elem))
				end))
			:
			wrapped(forall (desc : U-tuple-desc-type, elem : (forall (rest : tuple-type(desc)) -> (next : U))) -> (res : U-tuple-desc-type))

let tuple-desc-singleton = lambda (U : universe, T : U)
	tuple-desc-elem-explicit(U)
		tuple-desc-empty U
		lambda ()
			T

host-tuple-of(tuple-desc-singleton(host-type, host-number))(4)