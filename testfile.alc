let prim-arith-binop = (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number))
let prim-sub = (intrinsic "return function(a, b) return a - b end" : prim-arith-binop)

#let prim-sub = (intrinsic "return function(a, b) return a - b end" : (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number)))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = prim-sub foo.bar y

# this should error becaused prim-type is not a prim-type and therefore can't be an arg to a prim-func-type
# but it doesn't.
let prim-array-type =
	intrinsic
		""""
			-- terms and terms_gen implicitly in env
			local value = terms.value
			assert(value and value.prim)
			local value_array = terms_gen.declare_array(value)
			local id = {name = "array"}
			--value.prim_user_defined_type({name = "array"}, value_array())
			local function mktype(elem)
				print("mktype id", id)
				print("mktype elem", elem)
				return value.qtype(
					value.quantity(terms.quantity.unrestricted),
					value.prim_user_defined_type(id, value_array(elem))
				)
			end
			return mktype
		:
		prim-func-type (T : (boxed prim-type)) -> (array : (boxed prim-type))

let array-type =
	lambda ((T : prim-type))
		let (typ) = (prim-array-type (box prim-type T))
		unbox prim-type typ

# FIXME: return arr after setting
let prim-array-set =
	intrinsic
		""""
			local function array_set(_elem_type, array, index, elem)
				-- we have to clone because can't guarantee input array isn't reused
				cloned = {}
				for i, v in ipairs(array) do
					cloned[i] = v
				end
				cloned[index] = elem
			end
			return array_set
		:
		prim-func-type (T : (boxed prim-type)) (arr : (array-type (unbox prim-type T))) (index : prim-number) (elem : (unbox prim-type T)) ->

let prim-array-get = 
	lambda ((T : prim-type))
		intrinsic
			""""
				local function array_get(array, index)
					return array[index]
				end
				return array_get
			:
			prim-func-type (arr : (array-type T)) (index : prim-number) ->  (elem : T)

let prim-array-new = 
	intrinsic
		""""
			local function array_new(_elem_type)
				return {}
			end
			return array_new
		:
		prim-func-type (T : (boxed prim-type)) ->  (arr : (array-type (unbox prim-type T)))

let array-set = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number, elem : T)
		let ( ) = prim-array-set(box(prim-type, T), arr, index, elem)

let array-get = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number)
		let typed-arr-get = (prim-array-get T)
		let (elem) = typed-arr-get(arr, index)
		# FIXME:
		# This type check fails because elem is referring to a placeholder from inside the typed-arr-get lambda
		# which is invalid, it should have been substituted
		# someone with a working lua debugger pls fix
		# it should be possible to step into the `inferrable_term:is_annotated() then` case in evalator
		# corresponding to this `the` operative and figure out why the elem side's type is referring to a placeholder from inside typed-arr-get
		# the expected behavior is for T to be the placeholder from line 89, and for elem's type to get substituted and end up as exactly the same placeholder
		# resulting in successful typecheck
		(the T elem)

let array-new = 
	lambda ((T : prim-type))
		let (elem) = prim-array-new(box(prim-type, T))
		elem

# let arr = array-new(prim-number)
# array-set(prim-number, arr, 1, 3)
# array-set(prim-number, arr, 2, 5)
	
# let (res) = prim-sub(3,array-get(prim-number, arr, 2))
# let (elem) = prim-array-get(box(prim-type, prim-number), arr, 2)

# let elem = array-get(prim-number, arr, 2)
# let elem2 = (the prim-number elem)
# let (res) = prim-sub(3, elem2)

let prim-array-get-bug-repro = 
	lambda ((T : prim-type))
		intrinsic
			""""
				local function array_get(index)
					--error "not valid to call, just to debug typechecker issue"
					return index
				end
				return array_get
			:
			prim-func-type (index : prim-number) -> (elem : T)

let typed-arr-get-bug-repro = (prim-array-get-bug-repro prim-number)
let (elem) = typed-arr-get-bug-repro(1)
let elem = (the prim-number elem)

elem

#let (val) =
#	+ x 5

#let (val) =
#	+ val y

#prim-sub foo.bar val

#	let (val) = (prim-sub 5 1)
	prim-sub val 3

	let sub = 
		lambda (x : prim-number, y : prim-number)
			let (val) = (prim-sub x y)
			val

	let from-array = 2
	let from-array = array-get(prim-number, arr, 2)

	sub 5 (sub 3 from-array)

# sub(array-get(prim-number, arr, 2), array-get(prim-number, arr, 1))
