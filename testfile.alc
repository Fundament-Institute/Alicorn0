let prim-arith-binop = (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number))
let prim-sub = (intrinsic "return function(a, b) return a - b end" : prim-arith-binop)

#let prim-sub = (intrinsic "return function(a, b) return a - b end" : (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number)))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = prim-sub foo.bar y

let prim-array-type =
	intrinsic
		""""
			-- terms and terms_gen implicitly in env
			local value = terms.value
			assert(value and value.prim)
			local value_array = terms_gen.declare_array(value)
			local id = {name = "array"}
			--value.prim_user_defined_type({name = "array"}, value_array())
			local function mktype(elem)
				print("mktype id", id)
				print("mktype elem", elem)
				return value.qtype(
					value.quantity(terms.quantity.unrestricted),
					value.prim_user_defined_type(id, value_array(elem))
				)
			end
			return mktype
		:
		prim-func-type (T : (boxed prim-type)) -> (array : (boxed prim-type))

let array-type =
	lambda ((T : prim-type))
		let (typ) = (prim-array-type (box prim-type T))
		unbox prim-type typ

# FIXME: return arr after setting
let prim-array-set =
	lambda ((T : prim-type))
		intrinsic
			""""
				local function array_set(array, index, elem)
					-- we have to clone because can't guarantee input array isn't reused
					-- Yet. growth mindset.
					cloned = {}
					for i, v in ipairs(array) do
						cloned[i] = v
					end
					cloned[index] = elem
					return cloned
				end
				return array_set
			:
			prim-func-type (arr : (array-type T)) (index : prim-number) (elem : T) -> (arr : (array-type T))

let prim-array-get = 
	lambda ((T : prim-type))
		intrinsic
			""""
				local function array_get(array, index)
					return array[index]
				end
				return array_get
			:
			prim-func-type (arr : (array-type T)) (index : prim-number) ->  (elem : T)

let prim-array-new =
	lambda ((T : prim-type))
		intrinsic
			""""
				local function array_new(_elem_type)
					return {}
				end
				return array_new
			:
			prim-func-type ->  (arr : (array-type T))

let array-set = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number, elem : T)
		let (arr) = (prim-array-set(T) arr index elem)
		arr

let array-get = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number)
		let typed-arr-get = (prim-array-get T)
		let (elem) = typed-arr-get(arr, index)
		(the T elem)

let array-new = 
	lambda ((T : prim-type))
		let (elem) = (prim-array-new(T))
		elem

let arr = array-new(prim-number)
let arr = array-set(prim-number, arr, 1, 3)
let arr = array-set(prim-number, arr, 2, 5)
	
let (res) = prim-sub(3,array-get(prim-number, arr, 2))
#	let (elem) = prim-array-get(box(prim-type, prim-number), arr, 2)

#	let elem = array-get(prim-number, arr, 2)
	let elem2 = (the prim-number elem)
	let (res) = prim-sub(3, elem2)


#	let (val) = (prim-sub 5 1)
	prim-sub val 3

	let sub = 
		lambda (x : prim-number, y : prim-number)
			let (val) = (prim-sub x y)
			val

	let from-array = 2
	let from-array = array-get(prim-number, arr, 2)

	sub 5 (sub 3 from-array)

# sub(array-get(prim-number, arr, 2), array-get(prim-number, arr, 1))

res
