#let x = 621
#let y = 926
#let prim-add = +

let prim-arith-binop = (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number))
let prim-sub = (intrinsic "return function(a, b) return a - b end" : prim-arith-binop)

#let prim-sub = (intrinsic "return function(a, b) return a - b end" : (prim-func-type (a : prim-number) (b : prim-number) -> (c : prim-number)))

#let foo = (record (bar = 5) (baz = 6))
#let subbed = prim-sub foo.bar y

# this should error becaused prim-type is not a prim-type and therefore can't be an arg to a prim-func-type
# but it doesn't.
let prim-array-type =
	intrinsic
		""""
			-- terms and terms_gen implicitly in env
			local value = terms.value
			assert(value and value.prim)
			local value_array = terms_gen.declare_array(value)
			local id = {name = "array"}
			--value.prim_user_defined_type({name = "array"}, value_array())
			local function mktype(elem)
				print("mktype id", id)
				print("mktype elem", elem)
				return value.qtype(
					value.quantity(terms.quantity.unrestricted),
					value.prim_user_defined_type(id, value_array(elem))
				)
			end
			return mktype
		:
		prim-func-type (T : (boxed prim-type)) -> (array : (boxed prim-type))

let array-type =
	lambda ((T : prim-type))
		let (typ) = (prim-array-type (box prim-type T))
		unbox prim-type typ

let prim-array-set =
	intrinsic
		""""
			local function array_set(_elem_type, array, index, elem)
				array[index] = elem
			end
			return array_set
		:
		prim-func-type (T : (boxed prim-type)) (arr : (array-type (unbox prim-type T))) (index : prim-number) (elem : (unbox prim-type T)) ->

let prim-array-get = 
	intrinsic
		""""
			local function array_get(_elem_type, array, index)
				return array[index]
			end
			return array_get
		:
		prim-func-type (T : (boxed prim-type)) (arr : (array-type (unbox prim-type T))) (index : prim-number) ->  (elem : (unbox prim-type T))


let example = unbox(prim-type, box(prim-type, prim-number))

let (typ) = (prim-array-type (box prim-type prim-number))
let example = unbox(prim-type, typ)

let array-set = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number, elem : T)
		let boxed_t = box(prim-type, T)
		let arr_ty = (array-type (unbox prim-type boxed_t))
		let elem_ty = (unbox prim-type boxed_t)
		let ( ) = prim-array-set(box(prim-type, T), arr, index, elem)

let prim-array-new = 
	intrinsic
		""""
			local function array_new(_elem_type)
				return {}
			end
			return array_new
		:
		prim-func-type (T : (boxed prim-type)) ->  (arr : (array-type (unbox prim-type T)))

let array-set = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number, elem : T)
		let ( ) = prim-array-set(box(prim-type, T), arr, index, elem)
let array-get = 
	lambda (T : prim-type, arr : (array-type T), index : prim-number)
		let (elem) = prim-array-get(box(prim-type, T), arr, index)
		elem
let array-new = 
	lambda ((T : prim-type))
		let (elem) = prim-array-new(box(prim-type, T))
		elem

let arr = array-new(prim-number)
array-set(prim-number, arr, 1, 3)
array-set(prim-number, arr, 2, 5)

#let (val) =
#	+ x 5

#let (val) =
#	+ val y

#prim-sub foo.bar val

let (val) = (prim-sub 5 1)
prim-sub val 3

#let number-array = (array-type (box prim-type prim-number))

let sub = 
	lambda (x : prim-number, y : prim-number)
		let (val) = (prim-sub x y)
		val

#let from-array = 2
let from-array = array-get(prim-number, arr, 2)

sub 5 (sub 3 from-array)

# sub(array-get(prim-number, arr, 2), array-get(prim-number, arr, 1))
